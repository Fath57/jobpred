import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GenerateWeKnowYouDto } from '../dto/generate-we-know-you.dto';

@Injectable()
export class PerplexityService {
  private readonly logger = new Logger(PerplexityService.name);
  private readonly apiKey: string;
  private readonly baseUrl = 'https://api.perplexity.ai/chat/completions';

  constructor(private configService: ConfigService) {
    this.apiKey = this.configService.get('PERPLEXITY_API_KEY');
  }

  async generateWeKnowYouText(data: GenerateWeKnowYouDto): Promise<{
    research: string;
    profile: string;
    sources: string[];
    confidence: number;
  }> {
    try {
      // Fallback si pas de clé API
      if (!this.apiKey) {
        this.logger.warn('No Perplexity API key found, using fallback text');
        return this.generateFallbackResearch(data);
      }

      const researchPrompt = this.buildResearchPrompt(data);
      
      // Timeout de 30 secondes pour la recherche approfondie
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);
      
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'sonar', // Modèle de recherche approfondie
          messages: [
            {
              role: 'system',
              content: 'You are a deep research assistant specialized in professional profile analysis. Provide comprehensive information about the person, their professional background, achievements, and career trajectory. Be factual and detailed.'
            },
            {
              role: 'user',
              content: researchPrompt
            }
          ],
          max_tokens: 1000, // Plus de tokens pour une recherche approfondie
          temperature: 0.3, // Plus factuel pour la recherche
        }),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text();
        this.logger.error(`Perplexity API error: ${response.status} - ${errorText}`);
        throw new Error(`Perplexity API error: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      const researchContent = result.choices?.[0]?.message?.content?.trim();

      if (!researchContent) {
        throw new Error('No research content generated by Perplexity API');
      }

      // Extraire les sources et calculer la confiance
      const sources = this.extractSources(result);
      const confidence = this.calculateConfidence(researchContent, sources);
      
      // Générer un profil basé sur la recherche
      const profile = this.generateProfileFromResearch(data, researchContent);
      
      this.logger.log(`Deep research completed for ${data.fullName} (${researchContent.length} chars, ${sources.length} sources, confidence: ${confidence}%)`);
      
      return {
        research: researchContent,
        profile,
        sources,
        confidence
      };

    } catch (error) {
      this.logger.error('Error in deep research:', error);
      
      // Fallback research if API fails
      return this.generateFallbackResearch(data);
    }
  }

  private buildResearchPrompt(data: GenerateWeKnowYouDto): string {
    let prompt = `Deep research sur ${data.fullName}`;
    
    if (data.linkedin) {
      prompt += `, LinkedIn : ${data.linkedin}`;
    }
    
    if (data.location) {
      prompt += `, basé(e) à ${data.location}`;
    }
    
    if (data.desiredPosition) {
      prompt += `, dans le domaine de ${data.desiredPosition}`;
    }
    
    prompt += `. Recherche des informations sur : son parcours professionnel, ses compétences, ses réalisations, son expérience, ses formations, ses projets notables, et tout autre élément pertinent pour comprendre son profil professionnel.`;
    
    return prompt;
  }

  private extractSources(result: any): string[] {
    try {
      // Extraire les sources depuis la réponse de l'API
      const sources = result.search_results || [];
      return sources.map((source: any) => source.url || source.title || 'Source inconnue').filter(Boolean);
    } catch (error) {
      this.logger.warn('Error extracting sources:', error);
      return [];
    }
  }

  private calculateConfidence(researchContent: string, sources: string[]): number {
    // Calculer la confiance basée sur la longueur du contenu et le nombre de sources
    const contentLength = researchContent.length;
    const sourceCount = sources.length;
    
    // Score basé sur la longueur (0-50 points)
    const lengthScore = Math.min(contentLength / 20, 50);
    
    // Score basé sur les sources (0-30 points)
    const sourceScore = Math.min(sourceCount * 10, 30);
    
    // Score basé sur la présence de mots-clés professionnels (0-20 points)
    const professionalKeywords = ['expérience', 'compétences', 'projet', 'entreprise', 'formation', 'diplôme', 'certification'];
    const keywordMatches = professionalKeywords.filter(keyword => 
      researchContent.toLowerCase().includes(keyword)
    ).length;
    const keywordScore = Math.min(keywordMatches * 3, 20);
    
    const totalScore = lengthScore + sourceScore + keywordScore;
    return Math.min(Math.round(totalScore), 100);
  }

  private generateProfileFromResearch(data: GenerateWeKnowYouDto, researchContent: string): string {
    // Générer un profil personnalisé basé sur la recherche
    const location = data.location ? ` basé(e) à ${data.location}` : '';
    const position = data.desiredPosition ? ` dans le domaine de ${data.desiredPosition}` : '';
    
    // Extraire les informations clés de la recherche
    const keyInfo = this.extractKeyInformation(researchContent);
    
    let profile = `Tu es ${data.fullName}${location}${position}.`;
    
    if (keyInfo.experience) {
      profile += ` ${keyInfo.experience}`;
    }
    
    if (keyInfo.skills) {
      profile += ` Tu maîtrises ${keyInfo.skills}.`;
    }
    
    if (keyInfo.achievements) {
      profile += ` ${keyInfo.achievements}`;
    }
    
    profile += ` Tu recherches de nouvelles opportunités professionnelles qui correspondent à ton expertise.`;
    
    return profile;
  }

  private extractKeyInformation(researchContent: string): {
    experience?: string;
    skills?: string;
    achievements?: string;
  } {
    const info: any = {};
    
    // Extraire l'expérience
    const experienceMatch = researchContent.match(/(\d+)\s*(ans?|années?)\s*d'expérience/i);
    if (experienceMatch) {
      info.experience = `avec ${experienceMatch[1]} ans d'expérience professionnelle`;
    }
    
    // Extraire les compétences
    const skillsKeywords = ['React', 'Node.js', 'Python', 'JavaScript', 'TypeScript', 'Java', 'C#', 'PHP', 'SQL', 'MongoDB', 'AWS', 'Docker', 'Kubernetes'];
    const foundSkills = skillsKeywords.filter(skill => 
      researchContent.toLowerCase().includes(skill.toLowerCase())
    );
    if (foundSkills.length > 0) {
      info.skills = foundSkills.slice(0, 3).join(', ');
    }
    
    // Extraire les réalisations
    const achievementKeywords = ['projet', 'réalisé', 'développé', 'créé', 'dirigé', 'géré', 'optimisé'];
    const hasAchievements = achievementKeywords.some(keyword => 
      researchContent.toLowerCase().includes(keyword)
    );
    if (hasAchievements) {
      info.achievements = 'Tu as une expérience solide dans la réalisation de projets complexes';
    }
    
    return info;
  }

  private buildEnhancedPrompt(data: GenerateWeKnowYouDto): string {
    let prompt = `Génère une description de profil professionnel personnalisée pour ${data.fullName}`;
    
    // Informations de base
    prompt += ` qui souhaite un poste de ${data.desiredPosition}`;
    
    if (data.location) {
      prompt += ` basé(e) à ${data.location}`;
    }
    
    // Contexte professionnel enrichi
    if (data.linkedin) {
      prompt += `. Profil LinkedIn disponible pour plus de contexte professionnel`;
    }
    
    if (data.additionalContext) {
      prompt += `. Informations supplémentaires importantes : ${data.additionalContext}`;
    }
    
    // Instructions spécifiques
    prompt += `.
    
    Crée un texte qui :
    - Met en valeur le profil professionnel de manière authentique
    - Intègre naturellement les informations fournies
    - Suggère des compétences et expériences pertinentes pour le poste
    - Reste professionnel mais accessible
    - Évite les clichés et les phrases génériques
    
    Le texte doit être engageant et donner envie d'en savoir plus sur cette personne.`;
    
    return prompt;
  }

  private buildPrompt(data: GenerateWeKnowYouDto): string {
    let prompt = `Génère une description de profil professionnel pour ${data.fullName}, qui souhaite un poste de ${data.desiredPosition}`;
    
    if (data.location) {
      prompt += ` basé(e) à ${data.location}`;
    }
    
    if (data.linkedin) {
      prompt += `. LinkedIn: ${data.linkedin}`;
    }
    
    if (data.additionalContext) {
      prompt += `. Informations supplémentaires: ${data.additionalContext}`;
    }
    
    prompt += `. Le texte doit être personnel, engageant, et commencer par "Tu es" ou "Tu es un(e)". Maximum 1500 mots.`;
    
    return prompt;
  }

  private cleanGeneratedText(text: string): string {
    // Supprimer les caractères indésirables
    let cleaned = text
      .replace(/^\s*["']|["']\s*$/g, '') // Supprimer les guillemets en début/fin
      .replace(/\s+/g, ' ') // Normaliser les espaces
      .trim();
    
    // S'assurer que le texte commence par "Tu es"
    if (!cleaned.toLowerCase().startsWith('tu es')) {
      cleaned = `Tu es ${cleaned}`;
    }
    
    // Limiter la longueur si nécessaire
    if (cleaned.length > 500) {
      cleaned = cleaned.substring(0, 500).trim();
      // S'assurer de terminer proprement
      const lastSentence = cleaned.lastIndexOf('.');
      if (lastSentence > 200) {
        cleaned = cleaned.substring(0, lastSentence + 1);
      }
    }
    
    return cleaned;
  }

  private generateFallbackResearch(data: GenerateWeKnowYouDto): {
    research: string;
    profile: string;
    sources: string[];
    confidence: number;
  } {
    const location = data.location ? ` basé(e) à ${data.location}` : '';
    const context = data.additionalContext ? `, ${data.additionalContext.toLowerCase()}` : '';
    
    // Fallback research basique
    const research = `Recherche limitée disponible pour ${data.fullName}${location}${context}. Informations de base : profil professionnel dans le domaine de ${data.desiredPosition || 'non spécifié'}.`;
    
    // Fallback profile
    const baseText = `Tu es ${data.fullName}, un(e) ${data.desiredPosition || 'professionnel'}${location}${context}`;
    
    // Ajouter des éléments contextuels selon le poste
    const positionKeywords = (data.desiredPosition || '').toLowerCase();
    let additionalContext = '';
    
    if (positionKeywords.includes('développeur') || positionKeywords.includes('developer')) {
      additionalContext = ' avec une passion pour l\'innovation technologique';
    } else if (positionKeywords.includes('manager') || positionKeywords.includes('chef')) {
      additionalContext = ' reconnu(e) pour ton leadership et ta capacité à fédérer les équipes';
    } else if (positionKeywords.includes('marketing') || positionKeywords.includes('commercial')) {
      additionalContext = ' avec un sens aigu de la stratégie et de la relation client';
    } else if (positionKeywords.includes('design') || positionKeywords.includes('créatif')) {
      additionalContext = ' avec une vision créative et une attention particulière aux détails';
    }
    
    const profile = `${baseText}${additionalContext}. Tu recherches de nouvelles opportunités professionnelles qui correspondent à tes compétences et à tes aspirations.`;
    
    return {
      research,
      profile,
      sources: ['Informations de base uniquement'],
      confidence: 30 // Faible confiance pour le fallback
    };
  }

  async validateApiKey(): Promise<boolean> {
    if (!this.apiKey) {
      this.logger.warn('PERPLEXITY_API_KEY not configured');
      return false;
    }

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'sonar', // Modèle de recherche approfondie
          messages: [{ role: 'user', content: 'Test de connexion' }],
          max_tokens: 10,
        }),
      });

      return response.ok;
    } catch (error) {
      this.logger.error('Error validating Perplexity API key:', error);
      return false;
    }
  }

  // Méthode de retry avec backoff exponentiel
  private async retryWithBackoff<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    baseDelay: number = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        if (attempt === maxRetries) {
          throw lastError;
        }
        
        const delay = baseDelay * Math.pow(2, attempt);
        this.logger.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    throw lastError!;
  }

  // Méthode pour générer avec retry
  async generateWeKnowYouTextWithRetry(data: GenerateWeKnowYouDto): Promise<{
    research: string;
    profile: string;
    sources: string[];
    confidence: number;
  }> {
    return this.retryWithBackoff(() => this.generateWeKnowYouText(data));
  }
}
